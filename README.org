#+title: Readme
#+Author: Pascal Jaeger
#+ATTR_ORG: :width 600
#+OPTIONS: toc:3

This is a Dactyl Manuform with a tracking ball in its right thumb cluster, a Tractyl Manuform so to speak, but since the is a Tractyl out there already, we rather refer to this trackball dactyl as the r_track.
Unlike some other trackball Dactyl Manuforms that utilize a [[https://www.pjrc.com/store/teensy.html][Teensy 2.0]] I managed to cram the firmware onto a Arduino Micro. Be aware that there is couple of hundred bytes left for hacking about. So if you want to add more custom stuff into your trackball Dactyl this one is probably not the best choice for you.

* Table of contents :TOC_3_gh:QUOTE:
#+BEGIN_QUOTE
- [[#about-this-repository][About this Repository]]
  - [[#license][License]]
- [[#building-guide-note-wip][Building guide NOTE: WIP]]
  - [[#needed-items][Needed items]]
    - [[#parts][Parts]]
    - [[#consumables][Consumables]]
    - [[#tools][Tools]]
  - [[#optional-enhance-the-3d-printed-case][(optional) Enhance the 3D printed case]]
  - [[#wiring--mounting][Wiring & Mounting]]
    - [[#try-mounting-the-usb-c-to-micro-usb-cable-and-the-trs-socket][Try mounting the USB-C to micro-USB cable and the TRS socket.]]
    - [[#wiring-diagrams][Wiring diagrams]]
    - [[#put-the-hot-swap-sockets-in-place][Put the hot swap sockets in place.]]
    - [[#solder-the-diodes-on][Solder the diodes on.]]
    - [[#solder-the-horizontal-lines][Solder the horizontal lines.]]
    - [[#solder-the-vertical-lines-in][Solder the vertical lines in.]]
    - [[#glue-the-hot-swap-sockets][Glue the hot swap sockets]]
    - [[#solder-the-jumper-wires-between-the-matrix-and-the-arduino-and-between-the-trs-socket-and-the-arduino][Solder the jumper wires between the matrix and the Arduino and between the TRS socket and the Arduino.]]
    - [[#solder-the-pmw3360-trackball-sensor][Solder the PMW3360 trackball sensor]]
    - [[#mounting-and-soldering-the-reset-switch][Mounting and soldering the reset switch]]
    - [[#mount-the-ball-bearings-for-the-trackball][Mount the ball bearings for the trackball.]]
    - [[#mount-the-m3-insert-nuts][Mount the M3 insert nuts]]
    - [[#mount-the-m2-insert-nuts][Mount the M2 insert nuts]]
    - [[#putting-everything-together][Putting everything together]]
- [[#flashing-the-firmware][Flashing the firmware]]
  - [[#a-word-about-trackball-modes][A word about trackball modes]]
    - [[#cursor-mode][Cursor mode]]
    - [[#carret-mode][Carret mode]]
    - [[#scroll-mode][Scroll mode]]
    - [[#sound-and-brightness-mode][Sound and brightness mode]]
    - [[#integration-mode][Integration mode]]
  - [[#draft-preparing-the-qmk-firmware][DRAFT: Preparing the QMK firmware]]
    - [[#setting-up-qmk][Setting up QMK]]
    - [[#customizing-your-key-map][Customizing your key map]]
    - [[#other-things-to-set-in-the-firmware][Other things to set in the firmware]]
    - [[#compiling-your-firmware][Compiling your firmware]]
  - [[#draft-flashing-the-compiled-hex-file][DRAFT: Flashing the compiled .hex file.]]
    - [[#install-avrdude][Install avrdude]]
    - [[#get-your-device-name][Get your device name]]
    - [[#flashing-the-hex][Flashing the .hex]]
#+END_QUOTE

* About this Repository
The idea and all the models come from Reddit user [[https://www.reddit.com/user/qqurn/][u/qqurn]]. Check out his Gitlab repository [[https://gitlab.com/keyboards1][here.]]
I only changed his models in Openscad to use a different USB-C to micro-USB adapter cable and a TRS socket and single serial communication between the halfs instead of a RJ9 socket and I2C communication.

The folder [[file:STLs/][STLs]] contains the .stl files ready to print. The folder [[file:models/][models]] contains the [[https://openscad.org/][OpenSCAD]] and [[https://www.freecadweb.org/][FreeCAD]] files to change the models to your liking in those programs.
I added some more images that are not included in the build guide into the folder [[file:images/more_images/][more_images]].

** License
Please note that the [[file:images/more_images/Pinout-Micro_latest.png][Arduino Micro pinout image]] and the part that is used in the image of the [[file:images/wiring_right.png][right sides wiring diagram]] is [[https://creativecommons.org/licenses/by-sa/4.0/][CC-BY-SA]] licensed. The image is work of [[https://www.arduino.cc/][Arduino]].
All other images are [[https://creativecommons.org/licenses/by-sa/4.0/][CC-BY-SA]] licensed as well.

* Building guide NOTE: WIP

** Needed items

I apologize if most of these parts are from German ebay vendors, but this is where I got them from. I am sure you can find them from somewhere else. I list the exact amount of parts needed, for some things it makes sense to have some spare, like switches, diodes, jumper wires. Many of the parts come in packages of a 100 or so, so you have so spares anyway.

*** Parts
- 3D printed case. Because of the Kailh hot swap sockets we are using make sure that the print quality is not too bad. If they don't fit properly it gets very hard to hit the sockets with the pins from the switches.
- 62 keyboard switches. Any of the usual Cherry style switches will work. Cherry, Kailh, Gateron, you name it.
- 62 1N4148 Diodes, if you buy some that are neatly packaged [[https://www.aliexpress.com/item/1934432186.html?spm=a2g0o.order_list.0.0.7cfc5c5f0jf1KF&gatewayAdapt=glo2deu][like this]] you can bend their pins in the shape you need easier.
- [[https://kprepublic.com/products/kailh-hot-swapping-pcb-sockets-for-mx-cherry-gateron-outemu-kailh-switches-for-xd75-series-smd-socket][62 Kailh hot swap sockets]]
- [[https://www.aliexpress.com/item/1005001486831290.html?spm=a2g0o.order_list.0.0.7cfc5c5f0jf1KF][2 USB-C to Micro-USB cable adapter.]] I edited the holes in the cases to fit these adapters, change the [[file:models/][models]] if you are using a different one. Not that you can also change the .stl files is OpenSCAD, which is sometimes easier if you only change a minor thing.
- 1 USB-C to USB-A cable. Or USB-C to USB-C. Or however you want to connect the keyboard to your computer.
- [[https://store.arduino.cc/products/arduino-micro][1 Arduino Micro]] with Micro-USB.
- [[https://www.aliexpress.com/item/32768308647.html?spm=a2g0o.order_list.0.0.7cfc5c5f0jf1KF][1 Arduino Pro Micro]] with Micro-USB.
- [[https://www.ebay.de/itm/323789560343?epid=2099768346&hash=item4b635c9a17:g:HkgAAOSwFPFh~a9D][1 TRS 3,5mm cable.]]
- [[https://www.ebay.de/itm/275315539359?hash=item401a15bd9f:g:r7EAAOSwJIZhYdp6][2 TRS 3.5mm sockets.]] (I used a TRRS socket in the photos, because I was trying I2C out. Don't let that throw you off.)
- [[https://www.ebay.de/itm/125233269308?var=426269832926][46 Jumper wires.]] Female-Male. In most cases 10cm is sufficient, but buy some 20cm, too.
- [[https://www.ebay.de/itm/173779404364?var=472450338468][12 M3x4 insert nuts.]]
- [[https://www.ebay.de/itm/173779404364?var=473397195689][2 M2x3 insert nuts.]]
- [[https://www.ebay.de/itm/165427883523?var=464984918399][12 screws M3x6.]]
- [[https://www.ebay.de/itm/261298209327?var=560230293992][2 screws M2x8.]] These are for mounting the PMW3360 sensor. Make sure you buy some with a small head, like the ones in the link.
- [[https://www.ebay.de/itm/160834871787?var=460084672768][Some bumper pads to prevent the keyboard from slipping all over the place.]]
- [[https://www.tindie.com/products/jkicklighter/pmw3360-motion-sensor/][1 PMW3360 Motion Sensor.]]
- [[https://www.ebay.de/itm/261317712140][3 MR63ZZ ball bearings]]
- [[https://www.ebay.de/itm/303970479238][3 3mm pins.]] I bought them in 10mm length and cut them off, because I could not find anything shorter. You need about 7mm long ones actually.
- [[https://de.perixx.com/products/18028][1 34mm trackball.]]
- [[https://www.aliexpress.com/item/32960657626.html?spm=a2g0o.productlist.0.0.1a0e284567qEMN&algo_pvid=23baa503-3c28-4c0c-a758-077bc9ae08db&algo_exp_id=23baa503-3c28-4c0c-a758-077bc9ae08db-2&pdp_ext_f=%7B%22sku_id%22%3A%2266505501610%22%7D&pdp_npi=2%40dis%21EUR%21%211.04%21%21%211.51%21%21%402100bdd816527763187435940eca76%2166505501610%21sea][1 6x6x4.3mm reset button.]] Anything in a different size you have lying around will probably do, too. The flatter the better.
- Some key caps you like with cherry mount. (nearly all of them have cherry mounts) I personally prefer SA sculpted key caps with dactyls although for someone who uses Dvorak a set that has everything (Dvorak and dactyl special keys) is hard to get.

*** Consumables
- wire, you can wire this however you like. I use insulated wire with 0.5mm diameter, but I have another Dactyl which I wired with 1mm thick uninsulated wire bent into shape so the wires do not touch. (like they wired old radios in the 50s.) It is very reliable.
- solder, it depends on personal preference, but I used solder with 1mm diameter
- some viscous glue
- hot glue
- multi meter (to check for continuity, a cheap one is enough)
- (optional) [[https://www.ebay.de/itm/284658986388?epid=11017008009&hash=item4246ff6d94:g:J6oAAOSw9KFie1tU][filler]]
- (optional) some paint you like

*** Tools
- soldering iron
- hot glue gun
- maybe 3D printer if you print yourself
- small screwdriver
- small hex keys for the screws
- nose pliers
- wire cutters
- metal saw
- electric drill
- 3mm drill bit
- (maybe) a round file

** (optional) Enhance the 3D printed case

This step is completely optional and there a many ways of enhancing a 3D print out there, but I wanted to share this regardless. Just in case you are not that much into 3D printing there is maybe some new stuff here for you.
So what I found very effective to increase the surfaces of 3D prints is filler that is spray able. (not filler paint, it is even thicker than that.)
I sand the 3D print with approx. 120 grit sandpaper before, just to make the surface a little bit smoother. Then I spray the primer on for the first time. Spray it very thin. It should not be soaking wet, because then in takes ages to dry. If it is thin enough it will be dry in 5 minutes.
Then I sand the surface with 120 grit again. I don't sand it too much but against the 'grain', so that the 'hills' are sanded off but the filler stays in the 'valleys'.
Then I spray on some filler again, wait 5 minutes and sand again. I do this for 3-4 times, after that I spray filler again, but this time a bit thicker and then let it dry over night.
This will give you a flat surface, where you can not see the the 3D print layers anymore. To get an ever better really shiny flat surface additional steps are needed of course, but this is a plastic casing of a keyboard, not a piano after all.
After that procedure I paint the case with normal paint from the hardware store. I think there are enough videos and tutorials on how to use spraying cans, so I won't get into that.
[[file:images/after-prime.jpg]]  [[file:images/after-paint.jpg]]

** Wiring & Mounting

*** Try mounting the USB-C to micro-USB cable and the TRS socket.
It could be that they don't fit, especially if you primed and painted the case. If they don't fit, use a round file to widen the holes a bit.
Do this first because it could be that the file ruins your paint and you want to paint that particular part again. You don't want to paint this again when the switches and everything is mounted.

*** Wiring diagrams
These are the wiring diagrams for the right and the left half. They will be useful in the next steps.
[[file:images/wiring_right.png]] [[file:images/wiring_left.png]]

*** Put the hot swap sockets in place.
I learned that it is easier to put the switches in now instead of doing it later. When putting in the switches, make sure that the pins of the switches hit the sockets. If they don't, they will bend to the side and you won't have a connection. If you look at the hot swap sockets closely, you can see the little pins from the switches sticking out a bit on the other side.
Don't be confused, the photos I have here are from before I learned that.
[[file:images/sockets-in.jpg]]

*** Solder the diodes on.
Now if you spend the few extra cents and bought diodes that are nicely packed in a row, this will pay off. Instead of bending and cutting the diodes one by one, you can bend them all at once using the edge of something. Then go berserk with the wire cutters. Cut only one side off, then it will be easier to hold them while soldering.
[[file:images/diodes-in.jpg]]

You can alter the position of the diodes, but not the direction. The black ring on the diode must point towards the horizontal line in the circuit. So either the diode is on the side of the switch with the horizontal line and the black ring pointing away from the switch, or it is on the side of the vertical line and the black ring pointing towards the switch. If you don't know what you are doing, just stick to the images and the wiring diagram. Luckily the 3D print has some recesses where the diodes should go, so it guides you a bit.
Cut the other side off when you are done soldering them.

*** Solder the horizontal lines.
Now solder the horizontal lines into their places. If you have bought normal (non fire resistant) wire, the insulation will melt away pretty easily. I prefer to melt it away with the soldering iron, then solder the wire onto the diode. However, this has some downsides. First of all, you can easily have soldered something that sticks to each other, but has no electrical connection. I check all of these connection with the multi meter to see if they are really connected to mitigate this and to save me the hassle of debugging this later on. Then there is the fumes, that are coming off the wire when it's melted. They don't smell very healthy, so be sure to open a window when doing this or have a fume hood. You can also remove the insulation here with a razor or something, which is probably the better and much nicer looking way, but then again this takes time.
[[file:images/horizontal-lines.jpg]]

*** Solder the vertical lines in.
This is basically the same thing like the horizontal lines. Now you could check with the multimeter if the switch really closes the circuit. Hold it to a vertical line and a horizontal line and press the corresponding switch.
[[file:images/vertical-lines.jpg]]

*** Glue the hot swap sockets
Now is a good time to glue the hot swap sockets in. Notice in the photo that I soldered the wires first, which was not the best idea ever.
Put a small amount of hot glue in the middle of every hot swap socket.
[[file:images/hot_glue_swaps.jpg]]

*** Solder the jumper wires between the matrix and the Arduino and between the TRS socket and the Arduino.
Now use those male-female jumper wires. Cut of a bit of the male end, then solder them to the vertical and horizontal lines first.
[[file:images/jumpers_to_mat.jpg]]
On the TRS socket it does not really matter which pin you use, as long as the same wire goes to the same pin on the other side.  (The color of the wiring diagram is the same on both sides, so the red line on the left side is the red line on the right side and so on.) However, use the sleeve for the ground at least, it is usually the one that is on the outside of the socket.
I tend to use tip for the voltage and the rings for communication, but that is entirely up to you.
When you are done, connect the wires to the Arduino.
[[file:images/jumpers_to_arduino.jpg]]

*** Solder the PMW3360 trackball sensor
A short note about soldering electronics: Unlike the switches, the wires or the TRS socket for example, which are quite sturdy, small electronic boards are a bit more sensitive. You can fry them with the soldering iron. Try to put as few heat as possible into the chips. You can to this by putting the solder on the soldering iron first, then touching the place you want to solder just long enough for everything to heat up enough so the solder can flow into its place.
Solder the wires to the sensor first. You can solder the male ends in again, then cut them off on the other side. Make sure to cut them off low enough so the plastic lense thingy still fits.
[[file:images/solder_pmw.jpg]] [[file:images/pmw_plastic_lense.jpg]]

After that connect the wires to the Arduino.

*** Mounting and soldering the reset switch
If you want to have the reset switch in the bottom plate, drill a 3mm hole at the spot where it should go.
I noticed that 4.3mm height for the reset switch is actually to high to mount it under that bracket and I broke it off. Nothing that a bit of glue can't fix. You probably want to get even flatter ones, I had a few of those 4.3mm high ones to spare from another project.
[[file:images/reset_switch_in.jpg]]

Solder two longer wires to the reset switch on the bottom plate.
[[file:images/solder_reset.jpg]]

Now that the PMW3360 and the TRS socket is connected, you will notice that there is no GND pin left on the Arduino. So solder one of the wires coming from the switch to the GND pin you used on the TRS socket. Connect the other wire to any of the two reset pins of the Arduino.
[[file:images/reset_connect.jpg]]

*** Mount the ball bearings for the trackball.
If you bought pins for the bearings that are too long, put the bearing on the pin *before* sawing it off. Otherwise you could have problems putting the pins in when they are serrated from the vice or saw. Those small bearings are a very sensible part, don't make loud noises and let them sniff your hand before touching them.
Just kidding, just don't put them in the vice and don't put a force on the inner ring without putting the same force on the outer ring.
Once you have the pins in the right length, just press them into the recesses. PLA is rather soft, so they stick in there, make some room with the soldering iron in case they don't go in. Once they are in you can correct their position, which determines the height of the ball and the distance between the PMW3360 and the Ball by heating them up with the soldering iron.
[[file:images/bearings-in.jpg]]

*** Mount the M3 insert nuts
Mounting those nuts is easy if you found nuts that are big enough for the holes. You put them on your soldering iron, heat them up, then press them into the 3D print. Just make sure your soldering iron is clean from solder, otherwise solder will block the thread and screws wont go in easily.
If you couldn't find nuts that are big enough, glue them in. Here is a trick how to get them in the right position: Pre-mount them on the bottom plate with a screw, like this:[[file:images/insert_prepare.jpg]]

Then put some glue on the insert nuts. Then mount the bottom plate into place, wait until the glue has dried and them remove the screws. Try to only put glue on the outside and use glue that is somewhat viscous so the glue wont flow into the inside from the bottom up.
[[file:images/inserts.jpg]]

*** Mount the M2 insert nuts
The M2 inserts and screws are for the PMW3360 sensor. Here you can mount them again to the PMW3360: [[file:images/pmw_prepare.jpg]]

Then you can glue them in. Note that the PMW must be mounted with the terminal holes up. (Down in this picture since the keyboard is upside down)
Make sure that the plastic lense that comes with the PMW lies on that surface as flat as it can get, otherwise the ball will be too far away from it.
[[file:images/pmw_in.jpg]]
Again, let the glue dry and then remove the screws and the sensor again.

*** Putting everything together
Before putting everything together, test the setup first. Connection problems are way easier to fix when the parts are not mounted yet. So continue with the firmware guide below before mounting everything.
The Arduino Micro has some pins on the top, which are in the way when mounting it. We do not need them, cut them off.
Here is the thing in all its glory:
[[file:images/done.jpg]]

* Flashing the firmware
** A word about trackball modes
What makes this firmware very special is how it handles the trackball. You can not only move the mouse pointer with it, no, you can have different modes for it and all that without using additional keys! How great is that?
What key activates what is set in ~config.h~, see [[#other-things-to-set-in-the-firmware][Other things to set in the firmware]].
The different modes are:
*** Cursor mode
Moves the mouse cursor as you would expect from a trackball.

*** Carret mode
Moves the cursor like you would be pressing the arrow keys.
Whats great about this is, that it will not go all over the place and up and down. It has as activation threshold, so if you roll the ball up and slightly to the side, it will only go up and not go to the side.

*** Scroll mode
Scrolls up and down and like and right like a mouse wheel from outer space.

*** Sound and brightness mode
Increases/ decreases volume when the trackball is rotated vertically and brightness when its rotated horizontally.

*** Integration mode
Integration mode is a special mode that sits on top of cursor, carret and scroll mode. It is activated when you hold the key for the RAISE layer. Integration mode tries to mitigate the problem with trackball that you have to re-grab the trackball after a short distance. It does this by using by keeping the velocity of the movement regardless if you still move the trackball. Say you want to scroll up on a web page. You can activate scroll mode and with it integration mode. Then you give the trackball a little tap and it will keep scrolling. Another tap in the same direction will make it scroll faster, a tap in the other direction will make it scroll slower.

** DRAFT: Preparing the QMK firmware

*** Setting up QMK
Set up QMK for your operating system. Here is the [[https://docs.qmk.fm/#/getting_started_build_tools][offical instructions]].

***** Gentoo

For Gentoo Linux I made a little guide, since the official instructions do not work very well. Skip this part and stick to the official instructions above if you do not run Gentoo.

Make sure your kernel has [[https://wiki.gentoo.org/wiki/Arduino#Arduino_MEGA.2C_Atmega8U2.2C_Atmega16U2.2C_Atmega32U4.2C_Zero_.28CDC_ACM.29][support for Atmega32U]] enabled. (gentoo-kernel-bin and unmodified gentoo-kernel have it enabled)
To install the gcc for building avr programs, put
#+begin_src sh /etc/portage/package.accept_keywords
# for crossdev/ gcc-8.5 for qmk firmware
cross-avr/gcc **
#+end_src
into ~/etc/portage/package.accept_keywords~ or ~/etc/portage/package.accept_keywords/cross-avr-gcc~ respectively, depending on how you set up your system.

And put
#+begin_src sh /etc/portage/package.mask
# for crossdev/ gcc-8.5 for qmk firmware
>cross-avr/gcc-8.5.0-r1
#+end_src
into ~/etc/portage/package.mask~ or ~/etc/portage/package.mask/cross-avr-gcc~ respectively.
I do not know why this is necessary, because will will order crossdev to install GCC 8.5 later, but if I do not mask the newer version, it installs the newest version regardless.

Then run these commands:
#+begin_src sh
# install dependencies
sudo emerge dev-vcs/git dev-python/pip
# on gentoo the python command depends on which python version has pip installed (your $PYTHON_TARGET). Run the command like this: python3.9 -m ... if your PYTHON_TARGET is 3.9
python3.x -m pip install --user qmk
# to build the toolchain for compiling for the Arduino (Micro). Anything higher than GCC 8.x is not recommended by qmk. (And you WILL have errors)
sudo crossdev --stable --g '=8.5' --portage --target avr
#+end_src

Don't bother to run ~qmk setup~. It would complain because our install is missing some tool chains for other micro controllers, but we only need the avr-tools for the Atmega32U.
If you are done with crossdev, you can check with ~avr-gcc -v~ if you really have version 8.5.0 installed.
Continue with the guide with topic Linux below.

**** Linux
This probably works well for Windows and Mac, too. I do not know as I haven't tried.

#+begin_src sh
# clone and prepare the QMK-Firmware repo
git clone https://github.com/Schievel1/qmk_firmware_dm_r_track.git
cd qmk_firmware_dm_r_track/
make git-submodule
# to test if your toolchain works, compile something:
qmk compile -kb handwired/dactyl_manuform/5x6 -km default
#+end_src

If the compilation succeeds it will output
#+begin_src sh
Linking: .build/handwired_dactyl_manuform_5x6_default.elf                                           [OK]
Creating load file for flashing: .build/handwired_dactyl_manuform_5x6_default.hex                   [OK]
Copying handwired_dactyl_manuform_5x6_default.hex to qmk_firmware folder                            [OK]
Checking file size of handwired_dactyl_manuform_5x6_default.hex                                     [OK]
 * The firmware size is fine - 19456/28672 (67%, 9216 bytes free)
#+end_src
And you will now have the file ~handwired_dactyl_manuform_5x6_default.hex~ in the qmk_firmware folder. Delete it.
#+begin_src sh
rm handwired_dactyl_manuform_5x6_default.hex
#+end_src

*** Customizing your key map
You can use the standard layouts, currently there is Colemak, Dvorak and Qwerty for the r_track.
For Dvorak and Qwerty the base layer is very similar to the standard US layout of the alphanumeric keys.
Here is the Dvorak base layer, the positions for the non-alphanumeric keys is the same for the Qwerty base layer:
[[file:images/layer0.jpg]]

The Layer 1 and Layer 2 for Dvorak and Qwerty are the same. The MO(2) key will activate the second layer, when the MO(1) key from the base layer is pressed simultaneously.
[[file:images/layer1.jpg]] [[file:images/layer2.jpg]]

Inside your qmk_firmware_dm_r_track folder there is a folder with the key maps for the r_track under ~keymaps/handwired/dactyl_manuform/5x6_r_track/keymaps~.
This folder contains sub folders with custom sets of key maps. Now you have two choices:
- Edit one of the existing key maps
- Make your own key map. Copy one of the folders in ~keymaps/handwired/dactyl_manuform/5x6_r_track/keymaps~ in place and rename it to your liking. Copy the folder with a key map that is closest to what you want to make. (If you want to make a Dvorak layout, it is easier to start with Dvorak as draft)

**** OPTION 1: the hardcore way with a text editor
***** Key layout
Either way you will find a ~keymap.c~ file inside of those folders. This file is compiled into the actual part of the firmware that determines the keymap. Inside there is a part that looks something like this:
#+begin_src c
const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
[_COLEMAKDHM] = LAYOUT_5x6(
DM_REC1,    DM_REC1, DM_PLY1, DM_REC2 , DM_PLY2 , DM_RSTP,               KC_CPI_DOWN, KC_CPI_STD , KC_CPI_UP , KC_SMO_SC , KC_0        ,KC_QUOT_MY,
KC_TAB,     KC_Q ,   KC_W   , KC_F    , KC_P    , KC_B   ,               KC_J    ,    KC_L       , KC_U      , KC_Y      , KC_SCLN_INV ,KC_QUOT_MY,
KC_ESC,     KC_A ,   KC_R   , KC_S    , KC_T    , KC_G   ,               KC_M    ,    KC_N       , KC_E      , KC_I      , KC_O        ,KC_MINS,
KC_TILD_MY, KC_Z ,   KC_X   , KC_C    , KC_D    , KC_V   ,               KC_K    ,    KC_H       , KC_COMM   , KC_DOT    , KC_SLSH     ,KC_BSLASH,
                           _______, _______,                                         _______, KC_LGUI,
                                       TD(SFT_TM),    TD(RAI_TM),          _______, KC_SPC,
                                       TD(CTL_TM),    TD(GUI_TM),          _______, KC_ENT,
                                       TD(ALT_TM),    TD(LOW_TM),          KC_BSPC, KC_DEL
),

[_LOWER] = LAYOUT_5x6(

KC_TILD, KC_EXLM     , KC_AT   , KC_HASH   , KC_DLR  ,KC_PERC,           KC_CIRC, KC_AMPR , KC_ASTR    , KC_LPRN  , KC_RPRN   ,           _______,
_______, KC_PGDN     , KC_HOME , KC_END    , KC_PGUP ,_______,           _______, _______ , RALT(KC_Y) , _______  , RALT(LSFT(KC_SCLN)) , _______,
_______, RALT(KC_Q)  , _______ ,RALT(KC_S) , KC_RBRC ,_______,           KC_BTN3, KC_BTN1 , RALT(KC_5) , KC_BTN2  , RALT(KC_P),           _______,
KC_F12 , KC_F1       , KC_F2   , KC_F3     , KC_F4   , KC_F5 ,           KC_F6  , KC_F7   , KC_F8      , KC_F9    , KC_F10    ,           KC_F11 ,
                            _______,_______,                             _______,_______,
                                        _______,_______,             _______,_______,
                                        _______,_______,             _______,_______,
                                        _______,_______,             _______,_______
),

[_RAISE] = LAYOUT_5x6(
_______, _______ , _______ , _______ , _______ ,_______,                 _______, _______      , _______      , _______     , _______     , _______,
_______,  KC_1   , KC_2    , KC_3    , KC_4    , KC_5  ,                 KC_6   , KC_7         , KC_8         , KC_9        , KC_0        , KC_QUOT,
_______, KC_LPRN , KC_RPRN , KC_LBRC , KC_RBRC ,KC_LBRC,                 KC_RBRC, LSFT(KC_LBRC),LSFT(KC_RBRC) ,LSFT(KC_COMM),LSFT(KC_DOT) ,KC_MS_BTN3,
KC_TILD, KC_EXLM , KC_AT   , KC_HASH , KC_DLR  ,KC_PERC,                 KC_CIRC, KC_AMPR      , KC_ASTR      , KC_PLUS     , KC_EQL      , KC_DEL,
                             _______,_______,                                _______,_______,
                                        _______,_______,             _______,_______,
                                        _______,_______,             _______,_______,
                                        _______,_______,             _______,_______
),
};
#+end_src

This represents the layout of the keys. In order to change a key, you have to exchange the keycode of that key with the one you want. Say you want to have escape on the first key in the second row. Then you would exchange ~KC_TAB~ there with ~KC_ESC~. If you do not know the keycode of a key, you could use [[https://config.qmk.fm/#/handwired/dactyl_manuform/5x6/LAYOUT_5x6][QMK Configurator]]. When you hover your mouse over a key in the keyboard image on the bottom of a page, it shows you the keys keycode in a bar a the bottom.
To get special key functions like ~RALT(KC_Y)~ you can see them in the same way on the bottom in the "Quantum" tab.
Here is also a reference for the [[https://github.com/qmk/qmk_firmware/blob/master/docs/keycodes.md][keycodes used by QMK.]] There are a few.

****** Special key codes in this firmware
The firmware also has some additional keycodes which you can use in the matrix above like any other keycode.
| Keycode     | Function                                                                                                      |
|-------------+---------------------------------------------------------------------------------------------------------------|
| KC_SCLN_INV | Like KC_SCLN but gives you a : normally and ; when shift is pressed                                           |
| KC_QUOT_MY  | Types " and immitiatly space afterwards to mitigate dead keys on some international keyboards                 |
| KC_TILD_MY  | Types " and immitiatly space afterwards to mitigate dead keys on some international keyboards                 |
| KC_CPI_DOWN | Decrease the CPI one step, increase sensitivity of the trackball                                              |
| KC_CPI_UP   | Increase the CPI one step, decrease sensitivity of the trackball                                              |
| KC_CPI_STD  | Set the CPI value back to the value of [[PMW3360_CPI]] from config.h                                              |
| KC_SMO_SC   | Enable smooth scrolling with the trackball                                                                    |
| TD(SFT_TM)  | The normal left shift key, unless you only tab it, then it activates what you set as [[TRACK_MODE_][TRACK_MODE_SHIFT]]         |
| TD(GUI_TM)  | The normal left super/ GUI/ WIN key, unless you only tab it, then it activates what you set as [[TRACK_MODE_GUI]] |
| TD(ALT_TM)  | The normal left alt key, unless you only tab it, then it activates what you set as [[TRACK_MODE_ALT]]             |
| TD(CTL_TM)  | The normal left control key, unless you only tab it, then it activates what you set as [[TRACK_MODE_ALT][TRACK_MODE_CTRL]]        |
| TD(RAI_TM)  | activate the _RAISE layer                                                                                     |
| TD(LOW_TM)  | activate the _LOWER layer                                                                                     |
|-------------+---------------------------------------------------------------------------------------------------------------|

The keys ~TD(SFT_TM), TD(CTL_M) ...~ are special functions of the firmware for this r_tracks dactyl. They modify the behavior of the trackball, when only hold. When they are hold and a key is pressed, they behave like the normal key would. E.g. TD(SFT_TM) together with 'g' behaves like the normal shift-key together with 'g' and prints a G.
Be aware that ~TD(RAI_TM)~ and ~TD(LOW_TM)~ are modifier keys to activate the _RAISE and _LOWER layer.

***** Layers
In the above example [_COLEMAKDHM], [_LOWER] and [_RAISE] are the names of the layers. You can put in any name for the _COLEMAKDHM layer, but you have to change the ~#define~ lines at the beginning of the file accordingly.
#+begin_src c
#define _COLEMAKDHM 0
#+end_src
You better leave the RAISE and LOWER name like they are. You could change them, but you would have to change them everywhere in the file.
To add another layer, copy and past one of the existing layers, rename it to whatever you like, e.g. _MYLAYER. Then add a new ~#define _MYLAYER 3~ to the beginning of the file. Count the number up with every layer you add.
You bind your layer to a key with the keycode ~MO(_MYLAYER)~. MO switches a layer on like the shift, CTRL etc. keys. So when you hold that key down, the layer is active. When you let go, the layer is not active. Again there are several other layer functions like ~TG()~ which toggles a layer. Look them up in QMK Configurator.


**** OPTION 2: Using QMK Configurator for similar keyboard
Because editing the keycodes is somewhat tedious, I came up with a way to utilize QMK Configurator a bit for it.
Go to [[https://config.qmk.fm/#/handwired/dactyl_manuform/5x6/LAYOUT_5x6][QMK Configurator]] and select the handwired/dactyl_manuform/5x6 keyboard. Rename the keyboard to whatever you like and edit your keyboard to your liking.
You can also put functions on the keys that do not really exist because of the trackball, they just wont work.
When you are done, export the key map as JSON and put it into the qmk_firmware_dm_r_track folder. Then run the command
#+begin_src sh
qmk json-keymap handwired-dactyl_manuform-5x6-yourfilename.json >> mykeymap.c
#+end_src
With "yourfilename" changed to your actual filename of course. This will generate a C source file out of the JSON file. It will look something like this:
#+begin_src c
#include QMK_KEYBOARD_H

/* THIS FILE WAS GENERATED!
 *
 * This file was generated by qmk-compile-json. You may or may not want to
 * edit it directly.
 */

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
	[0] = LAYOUT_5x6(KC_GRV, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7, KC_8, KC_9, KC_0, KC_EQL, KC_TAB, KC_QUOT, KC_COMM, KC_DOT, KC_P, KC_Y, KC_F, KC_G, KC_C, KC_R, KC_L, KC_SLSH, KC_ESC, KC_A, KC_O, KC_E, KC_U, KC_I, KC_D, KC_H, KC_T, KC_N, KC_S, KC_MINS, KC_NO, KC_SCLN, KC_Q, KC_J, KC_K, KC_X, KC_B, KC_M, KC_W, KC_V, KC_Z, KC_BSLS, KC_LBRC, KC_RBRC, KC_PGUP, KC_PGDN, KC_LSFT, KC_NO, KC_NO, KC_RSFT, KC_LCTL, KC_SPC, KC_BSPC, KC_RALT, KC_LALT, MO(1), KC_ENT, LGUI_T(KC_RGUI)),
	[1] = LAYOUT_5x6(KC_TILD, KC_F1, KC_F2, KC_F3, KC_F4, KC_F5, KC_F6, KC_F7, KC_F8, KC_F9, KC_F10, KC_DEL, RCS(KC_2), KC_F9, KC_F10, LSFT(KC_F7), LCTL(KC_R), KC_LCBR, KC_RCBR, KC_HOME, KC_INS, KC_F11, KC_F12, KC_PLUS, KC_TRNS, RCS(KC_3), RCS(KC_4), MO(2), KC_DEL, KC_LPRN, KC_RPRN, KC_LEFT, KC_UP, KC_DOWN, KC_RGHT, KC_PIPE, KC_CAPS, LSFT(KC_F8), LSFT(KC_F9), LCTL(KC_X), LCTL(KC_C), LCTL(KC_V), KC_EQL, RCS(KC_3), RCS(KC_4), LSFT(KC_F8), LSFT(KC_F9), RCS(KC_2), LCTL(KC_F2), LCTL(KC_F3), KC_PSCR, KC_END, KC_LSFT, KC_TRNS, KC_TRNS, KC_RSFT, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS),
	[2] = LAYOUT_5x6(KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_NLCK, KC_PSLS, KC_PAST, KC_PMNS, KC_CALC, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_LBRC, KC_RBRC, KC_P7, KC_P8, KC_P9, KC_PPLS, KC_MUTE, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_LPRN, KC_RPRN, KC_P4, KC_P5, KC_P6, KC_TRNS, KC_VOLU, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_P0, KC_P1, KC_P2, KC_P3, KC_PEQL, KC_VOLD, KC_TRNS, KC_TRNS, KC_PDOT, KC_COMM, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS)
};
#+end_src

Where 0, 1 and 2 are the different layers.
While this is horrible to read of course, these layers are perfectly valid key maps. But you have to make some changes first before you can use it in the r_tracks firmware.
First of all, copy only the part that says
#+begin_src c
	LAYOUT_5x6(KC_GRV, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7, KC_8, KC_9, KC_0, KC_EQL, KC_TAB, KC_QUOT, KC_COMM, KC_DOT, KC_P, KC_Y, KC_F, KC_G, KC_C, KC_R, KC_L, KC_SLSH, KC_ESC, KC_A, KC_O, KC_E, KC_U, KC_I, KC_D, KC_H, KC_T, KC_N, KC_S, KC_MINS, KC_NO, KC_SCLN, KC_Q, KC_J, KC_K, KC_X, KC_B, KC_M, KC_W, KC_V, KC_Z, KC_BSLS, KC_LBRC, KC_RBRC, KC_PGUP, KC_PGDN, KC_LSFT, KC_NO, KC_NO, KC_RSFT, KC_LCTL, KC_SPC, KC_BSPC, KC_RALT, KC_LALT, MO(1), KC_ENT, LGUI_T(KC_RGUI)),
#+end_src

into an existing r_track layouts ~keymap.c~. So you will not mess up the names of the layers. Then you have to replace some key codes according to the table below:

| replace | with       |
|---------+------------|
| KC_LSFT | TD(SFT_TM) |
| KC_LGUI | TD(GUI_TM) |
| KC_LCTL | TD(CTL_TM) |
| KC_LALT | TD(ALT_TM) |
| MD(1)   | TD(LOW_TM) |
| MD(2)   | TD(RAI_TM) |
|---------+------------|

*** Other things to set in the firmware
On the bottom of the file ~keyboards/handwired/dactyl_manuform/5x6_r_track/config.h~ there are two settings that you might want play around with:

**** #define <<PMW3360_CPI>> 700
Lets you set the initial CPI of the trackball. The general sensitivity so to speak. Higher value means slower mouse pointer.

**** #define CPI_STEP_SENS 20
Let you set how much the sensitivity changes with one press off KC_CPI_UP/ KC_CPI_DOWN.

**** #define ROTATIONAL_TRANSFORM_ANGLE -30
This setting changes the direction where the mouse pointer goes, when you move the ball. I set it up so the mouse pointer moves horizontal for me when I move my extended thump from left to right. But you probably want a different setting.

**** #define CURSOR_MODE_SENS 500
Lets you set the sensitivity in cursor mode. Higher value means faster mouse pointer.

**** #define SCROLL_MODE_SENS 50
Lets you set the sensitivity in scroll mode. Higher value means slower scrolling.

**** #define CARRET_MODE_SENS 500
Lets you set the sensitivity in carret mode. Higher value means slower cursor.

**** #define CURSOR_INTE_SENS 5
Sets the sensitivity in cursor mode during integration mode. Higher value means faster pointer.

**** #define SCROLL_INTE_SENS 10000
Sets the sensitivity in scroll mode during integration mode. Higher value means slower scrolling.

**** #define CARRET_INTE_SENS 2000
Sets the sensitivity in carret mode during integration mode. Higher value means slower cursor.

**** #define <<TRACK_MODE_ALT>> SCROLL_MODE
Set which trackball mode should me activated when the key that is bound with TD(ALT_TM) is pressed. Values are:
- SCROLL_MODE
- CURSOR_MODE
- CARRET_MODE
- SND_BRIGHT_MODE

**** #define TRACK_MODE_(CTRL/ SHIFT/ GUI)
Same like ~#define TRACK_MODE_ALT~ for the CTRL/ SHIFT/ GUI key.

*** Compiling your firmware
Once you are done with setting up the keymap to your liking, you can generate a .hex file with the command
#+begin_src sh
qmk compile -kb handwired/dactyl_manuform/5x6_r_track -km <name_of_your_keymap>
#+end_src
while being inside the qmk_firmware_dm_r_track folder. If you haven't screwed up your keymap.c from before, this will generate a .hex-file in the qmk_firmware folder.

** DRAFT: Flashing the compiled .hex file.
Flashing the firmware is the usual flashing of a QMK firmware. You either compiled it yourself on your computer, with the somewhat finicky setup of the key map and compilation of the keymap.c, or with the rather comfortable [[https://config.qmk.fm/][QMK Configurator]]. Either way you are going to end up with a .hex file.
I have never flashed a QMK firmware onto an Arduino in Windows or Mac, but I guess it's rather easy using [[https://github.com/qmk/qmk_toolbox/releases][QMK Toolbox.]]

To flash a .hex in Linux you need to do the following:
*** Install avrdude
On Gentoo this is ~sudo emerge dev-embedded/avrdude~, on Ubuntu ~sudo apt install avrdude~ and I am confident someone nerdy enough to want to use such a keyboard knows how to install software on his/ her distro.
*** Get your device name
To get your device name in Linux you use the command ~dmesg | tail~. This shows you the end of the log of the kernel messages, so plug in the left side of the keyboard into your USB without the right side connected to it, put your Arduino into flash mode by pressing the reset button and run ~dmesg | tail~.
This will give you some output similar to
#+begin_src sh
~[26768.779976] cdc_acm 1-12:1.0: ttyACM0: USB ACM device~
#+end_src

Which is telling you that ~/dev/ttyACM0~ is the device name of your Arduino. Be aware that these device names are dynamic in Linux, so it could be ~/dev/ttyACM1~ next time, because you already have another Arduino (or some other USB/Serial device) plugged in, which already occupies ~/dev/ttyACM0~. Depending on your distro
this could also be called ~/dev/ttyUSB0~ instead.

If you can not find your device with ~dmesg | tail~, try finding it with
#+begin_src sh
find /dev -name '*ttyACM*' # or
find /dev -name '*ttyUSB*'.
#+end_src

It could be that the device is only accessible by root, so to get user access you can use ~sudo chmod 777 /dev/ttyACM0~, but this will only last until you reconnect the Arduino.
To get permanent rights to access the Arduino as a user, you could also find the group of the ~/dev/ttyACM*~ file with ~ls -la /dev | grep ttyACM~, which should output something like this:
~crw-rw-r-- 1 root dialout ... /dev/ttyACM~. Add yourself to the group dialout (in this case) to get read/write permissions with ~sudo usermod -a -G dialout myUserName~.
However, the group name ~dialout~ could depend on the distro.

*** Flashing the .hex
Now with all that information, put your Arduino into flash mode again by pressing the reset button. Use the command
#+begin_src sh
avrdude -v -patmega32u4 -cavr109 -P/dev/ttyACM0 -b57600 -Uflash:w:"handwired_dactyl_manuform_5x6_r_track_yourfilenamehere.hex":i
#+end_src
inside the folder where your .hex file is.
Where ~/dev/ttyACM0~ depends on the device name you obtained before and the filename of the .hex file is your own filename obviously.

Sometimes flashing Arduinos is a bit tricky. If they already have a program flashed to them, you put them into flashing mode by pressing the reset switch. Then they are in flashing mode for a few seconds before they start running in their normal mode again. So you have to press that reset switch then run that command fast. In case you did not add yourself to the group that owns ~/dev/ttyACM*~, it could be that you have to find the name of that device (/dev/ttyACMsomething), change its permissions and run the command. All that in a few seconds. You could chain commands together with ~&&~, but I recommend adding yourself to that group instead.
Other times you get things like ~avrdude: butterfly_recv(): programmer is not responding~. Then it helps to tap the reset button right after pressing enter on the upload command.
Then I have had it with several Arduino Pro Micros, that I had to hold the reset button for a short time, then let it go, then tap it. I guess there are just too many Arduino manufacturers out there, and each of them has its own quirks.
So do not panic if uploading does not work at the first try. It could certainly be, that your have so problem with avrdude, but most of the times it is just that you got the timing wrong.

Once you are done with flashing the left side, disconnect it. Then connect the right side and do the same procedure again. You use the same .hex file on both sides.
When you are done, connect the USB cable to the right side and use your new keyboard!
