#+title: Readme
#+Author: Pascal Jaeger
#+ATTR_ORG: :width 800

This is a Dactyl Manuform with a tracking ball in its right thumb cluster, a Tractyl Manuform so to speak, but since the is a Tractyl out there already, we rather refer to this trackball dactyl as the r_track.

* TODO Things that are still to TODO in the building guide:
- [ ] Wiring of the reset switch
- [ ] Insert photo of the wiring of the matrix to the Arduino
- [ ] Flashing of the right side

* Table of contents :toc:
- [[#things-that-are-still-to-todo-in-the-building-guide][Things that are still to TODO in the building guide:]]
- [[#about-this-repository][About this Repository]]
  - [[#license][License]]
- [[#building-guide-note-wip][Building guide NOTE: WIP]]
  - [[#needed-items][Needed items]]
  - [[#optional-enhance-the-3d-printed-case][(optional) Enhance the 3D printed case]]
  - [[#wiring--mounting][Wiring & Mounting]]
- [[#flashing-the-firmware][Flashing the firmware]]
  - [[#draft-preparing-the-qmk-firmware][DRAFT: Preparing the QMK firmware]]
  - [[#draft-flashing-the-compiled-hex-file][DRAFT: Flashing the compiled .hex file.]]

* About this Repository
The idea and all the models come from Reddit user [[https://www.reddit.com/user/qqurn/][u/qqurn]]. Check out his Gitlab repository [[https://gitlab.com/keyboards1][here.]]
I only changed his models in Openscad to use a different USB-C to micro-USB adapter cable and a TRRS socket instead of RJ9.

The folder [[file:STLs/][STLs]] contains the .stl files ready to print. The folder [[file:models/][models]] contains the [[https://openscad.org/][OpenSCAD]] and [[https://www.freecadweb.org/][FreeCAD]] files to change the models to your liking in those programs.
I added some more images that are not included in the build guide into the folder [[file:images/more_images/][more_images]].

** License
Please note that the [[file:images/more_images/Pinout-Micro_latest.png][Arduino Micro pinout image]] and the part that is used in the image of the [[file:images/wiring_right.png][right sides wiring diagram]] is [[https://creativecommons.org/licenses/by-sa/4.0/][CC-BY-SA]] licensed. The image is work of [[https://www.arduino.cc/][Arduino]].
All other images are [[https://creativecommons.org/licenses/by-sa/4.0/][CC-BY-SA]] licensed as well.

* Building guide NOTE: WIP

** Needed items

I apologize if most of these parts are from German ebay vendors, but this is where I got them from. I am sure you can find them from somewhere else. I list the exact amount of parts needed, for some things it makes sense to have some spare, like switches, diodes, jumper wires. Many of the parts come in packages of a 100 or so, so you have so spares anyway.

*** Parts
- 3D printed case. Because of the Kailh hot swap sockets we are using make sure that the print quality is not too bad. If they don't fit properly it gets very hard to hit the sockets with the pins from the switches.
- 62 keyboard switches. Any of the usual Cherry style switches will work. Cherry, Kailh, Gateron, you name it.
- 62 1N4148 Diodes, if you buy some that are neatly packaged [[https://www.aliexpress.com/item/1934432186.html?spm=a2g0o.order_list.0.0.7cfc5c5f0jf1KF&gatewayAdapt=glo2deu][like this]] you can bend their pins in the shape you need easier.
- [[https://kprepublic.com/products/kailh-hot-swapping-pcb-sockets-for-mx-cherry-gateron-outemu-kailh-switches-for-xd75-series-smd-socket][62 Kailh hot swap sockets]]
- [[https://www.aliexpress.com/item/1005001486831290.html?spm=a2g0o.order_list.0.0.7cfc5c5f0jf1KF][2 USB-C to Micro-USB cable adapter.]] I edited the holes in the cases to fit these adapters, change the [[file:models/][models]] if you are using a different one. Not that you can also change the .stl files is OpenSCAD, which is sometimes easier if you only change a minor thing.
- 1 USB-C to USB-A cable. Or USB-C to USB-C. Or however you want to connect the keyboard to your computer.
- [[https://store.arduino.cc/products/arduino-micro][1 Arduino Micro]] with Micro-USB.
- [[https://www.aliexpress.com/item/32768308647.html?spm=a2g0o.order_list.0.0.7cfc5c5f0jf1KF][1 Arduino Pro Micro]] with Micro-USB.
- [[https://www.aliexpress.com/item/1005003415667083.html?spm=a2g0o.order_list.0.0.7cfc5c5f0jf1KF][1 TRRS 3.5mm cable.]]
- [[https://www.reichelt.de/klinkeneinbaubuchse-3-5-mm-stereo-4-pol-lum-1502-02-p116189.html?PROVID=2788&r=1][2 TRRS 3.5mm sockets.]] This fourth pin is important. TRS wont do.
- [[https://www.ebay.de/itm/125233269308?var=426269832926][46 Jumper wires.]] Female-Male. In most cases 10cm is sufficient, but buy some 20cm, too.
- [[https://www.ebay.de/itm/173779404364?var=472450338468][10 M3x4 insert nuts.]]
- [[https://www.ebay.de/itm/173779404364?var=473397195689][2 M2x3 insert nuts.]]
- [[https://www.ebay.de/itm/165427883523?var=464984918399][10 screws M3x6]]
- [[https://www.ebay.de/itm/261298209327?var=560230293992][2 screws M2x6]]
- [[https://www.ebay.de/itm/160834871787?var=460084672768][Some bumper pads to prevent the keyboard from slipping all over the place.]]
- [[https://www.tindie.com/products/jkicklighter/pmw3360-motion-sensor/][1 PMW3360 Motion Sensor.]]
- [[https://www.ebay.de/itm/261317712140][3 MR63ZZ ball bearings]]
- [[https://www.ebay.de/itm/303970479238][3 3mm pins.]] I bought them in 10mm length and cut them off.
- [[https://de.perixx.com/products/18028][1 34mm trackball.]]
- [[https://www.aliexpress.com/item/32960657626.html?spm=a2g0o.productlist.0.0.1a0e284567qEMN&algo_pvid=23baa503-3c28-4c0c-a758-077bc9ae08db&algo_exp_id=23baa503-3c28-4c0c-a758-077bc9ae08db-2&pdp_ext_f=%7B%22sku_id%22%3A%2266505501610%22%7D&pdp_npi=2%40dis%21EUR%21%211.04%21%21%211.51%21%21%402100bdd816527763187435940eca76%2166505501610%21sea][1 6x6x4.3mm reset button.]] Anything in a different size you have lying around will probably do, too.
- Some key caps you like with cherry mount. (nearly all of them have cherry mounts) I personally prefer SA sculpted key caps with dactyls although for someone who uses Dvorak a set that has everything (Dvorak and dactyl special keys) is hard to get.

*** Consumables
- solder
- some viscous glue
- hot glue
- roll of insulated wire
- (optional) [[https://www.ebay.de/itm/284658986388?epid=11017008009&hash=item4246ff6d94:g:J6oAAOSw9KFie1tU][filler]]
- (optional) some paint you like
- (optional) multi meter (to check for continuity)

*** Tools
- soldering iron
- hot glue gun
- maybe 3D printer if you print yourself
- small screwdriver
- nose pliers
- wire cutters
- metal saw

** (optional) Enhance the 3D printed case

This step i completely optional and there a many ways of enhancing a 3D print out there, but I wanted to share this regardless. Just in case you are not that much into 3D printing there is maybe some new stuff here for you.
So what I found very effective to increase the surfaces of 3D prints is filler that is spray able. (not filler paint, it is even thicker than that.)
I sand the 3D print with approx. 120 grit sandpaper before, just to make the surface a little bit smoother. Then I spray the primer on for the first time. Spray it very think, it should not be soaking wet, because then in takes ages to dry. If it is thin enough it will be dry in 5 minutes.
Then I sand the surface with 120 grit again. I don't sand it too much and against the 'grain', so that the 'hills' are sanded off but the filler stays in the valley.
Then I spray on some filler again, wait 5 minutes and sand again. I do this for 3-4 times, after that I spray filler again, but this time a bit thicker and then let it dry over night.
This will give you a flat surface, where you can not the the 3D print grain anymore. To get an ever better really shiny flat surface additional steps are needed of course, but this is a plastic casing of a keyboard, not a piano after all.
After that procure I paint the case with normal paint from the hardware store. I think there are enough videos and tutorial an how to use spraying cans, so I won't get into that.
[[file:images/after-prime.jpg]]  [[file:images/after-paint.jpg]]

** Wiring & Mounting

*** Try mounting the USB-C to micro-USB cable and the TRRS socket.
It could be that they don't fit, especially if you primed and painted the case. If they don't fit, use a file to widen the holes a bit.
Do this first because it could be that the file ruins your paint and you want to paint that particular part again. You don't want to paint this again when everything is mounted.

*** Wiring diagrams:
[[file:images/wiring_right.png]] [[file:images/wiring_left.png]]

*** Put the hot swap sockets in place.
I learned that it is easier to put the switches in now instead of doing it later. When putting in the switches, make sure that the pins of the switches hit the sockets. If they don't, they will bend to the side and you wont have a connection. If you look at the hot swap sockets closely, you can see the little pins from the switches sticking out a bit on the other side.
Don't be confused, the photos I have here are from before I learned that.
[[file:images/sockets-in.jpg]]

*** Solder the diodes on.
Now if you spend the few extra cents and bought diodes that are nicely packed in a row, this will pay off. Instead of bending and cutting the diodes one by one, you can bend them all at once using the edge of something. Then go berserk with the wire cutters.
[[file:images/diodes-in.jpg]]

You can alter the position of the diode, but not the direction. The black ring on the diode must point towards the horizontal line in the circuit. So either the diode is on the side of the switch with the horizontal line and the black ring pointing away from the switch, or it is on the side of the vertical line and the black ring pointing towards the switch. If you don't know what you are doing, just stick to the images an the wiring diagram. Luckily the 3D print has some recesses where the diodes should go, so it guides you a bit.

*** Solder the horizontal lines.
Now solder the horizontal lines into their places. If you have bought normal (non fire resistant) wire, the insulation will melt away pretty easily. I prefer to melt it away with the soldering iron, then solder the wire onto the diode. However, this has some downsides. First of all, you can easily have soldered something that sticks to each other, but has no electrical connection. I check all of these connection with the multi meter to see if they are really connected to mitigate this and to save me the hassle of debugging this later on. Then there is the fumes, that are coming off the wire when it's melted. They don't smell very healthy, so be sure to open a window when  doing this or have a fume hood. You can also remove the insulation here with a razor or something, which is probably the better and much nicer looking way, but then again it takes time.
[[file:images/horizontal-lines.jpg]]

*** Solder the vertical lines in.
This is basically the same thing like the horizontal lines.
[[file:images/vertical-lines.jpg]]

*** Solder the jumper wires between the matrix and the Arduino and between the TRRS socket and the Arduino.
TODO

*** Mount the ball bearing for the trackball.
If you bought pins for the bearings that are too long, put the bearing on the pin *before* sawing it off. Otherwise you could have problems putting the puns in when the are serrated from the vice or saw. Those small bearings are very sensible part, don't make loud noises and let them sniff your hand before touching them.
Just kidding, just don't put them in the vice and don't put a force on the inner ring without putting the same force on the outer ring.
Once you have the pins in the right length, just press them into the recesses. PLA is rather soft, so they stick in there, make some room with the soldering iron in case they don't go in.
[[file:images/bearings-in.jpg]]

*** Mount the M3 insert nuts
Mounting those nuts is easy if you found nuts that are big enough for the holes. You put them on your soldering iron, heat them up, then press them into the 3D print. Just make sure your soldering iron is clean from solder, otherwise solder will block the thread and screws wont go in easily.
If you could find nuts that are big enough, glue them in. Here is a trick how to get them in the right position: Pre-mount them on the bottom plate with a screw, like this:[[file:images/insert_prepare.jpg]]

Then put some glue on the insert nuts. Then mount the bottom plate into place, wait until the glue has dried and them remove the screws. Try to only put glue on the outside and use glue that is somewhat viscous so the glue wont flow into the inside from the bottom up.
[[file:images/inserts.jpg]]

*** Mount the M2 insert nuts
The M2 inserts and screws are for the PMW3360 sensor. Here you can mount them again to the PMW3360: [[file:images/pmw_prepare.jpg]]
Then you can glue them in. Note that the PMW must be mounted with the soldering holes to up. (Down in this picture sinc the keyboard is upside down)
[[file:images/pmw_in.jpg]]
Again, let the glue dry and then remove the screw and the sensor.

* Flashing the firmware

** DRAFT: Preparing the QMK firmware

*** Setting up QMK
Set up QMK for your operating system. Here is the [[https://docs.qmk.fm/#/getting_started_build_tools][offical instructions]].

**** Gentoo
For Gentoo Linux, make sure your kernel has [[https://wiki.gentoo.org/wiki/Arduino#Arduino_MEGA.2C_Atmega8U2.2C_Atmega16U2.2C_Atmega32U4.2C_Zero_.28CDC_ACM.29][support for Atmega32U]] enabled. (gentoo-kernel-bin and unmodified gentoo-kernel have it enabled)
To install the gcc for building avr programs, put
#+begin_src sh /etc/portage/package.accept_keywords
# for crossdev/ gcc-8.5 for qmk firmware
cross-avr/gcc **
#+end_src
into ~/etc/portage/package.accept_keywords~ or ~/etc/portage/package.accept_keywords/cross-avr-gcc~ respectively, depending on how you set up your system.
And
#+begin_src sh /etc/portage/package.mask
# for crossdev/ gcc-8.5 for qmk firmware
>cross-avr/gcc-8.5.0-r1
#+end_src
into ~/etc/portage/package.mask~ or ~/etc/portage/package.mask/cross-avr-gcc~ respectively.

Then run:
#+begin_src sh
sudo emerge dev-vcs/git dev-python/pip # install dependencies
python3.x -m pip install --user qmk # on gentoo the python command depends on which python version has pip installed (your $PYTHON_TARGET). Run the command like this: python3.9 -m ... if your PYTHON_TARGET is 3.9
sudo crossdev --stable --g '=8.5' --portage --target avr # to build the toolchain for compiling for the Arduino (Micro). Anything higher than GCC 8.x is not recommended by qmk. (And you WILL have errors)
git clone https://github.com/qmk/qmk_firmware.git # clone the QMK-Firmware repo
cd qmk_firmware/
make git-submodule
# to test if your toolchain works, compile something:
qmk compile -kb handwired/dactyl_manuform/5x6 -km default
#+end_src

If the compilation suceeds it will output
#+begin_src sh
Linking: .build/handwired_dactyl_manuform_5x6_default.elf                                           [OK]
Creating load file for flashing: .build/handwired_dactyl_manuform_5x6_default.hex                   [OK]
Copying handwired_dactyl_manuform_5x6_default.hex to qmk_firmware folder                            [OK]
Checking file size of handwired_dactyl_manuform_5x6_default.hex                                     [OK]
 * The firmware size is fine - 19456/28672 (67%, 9216 bytes free)
#+end_src
And you will now have the file ~handwired_dactyl_manuform_5x6_default.hex~ in the qmk_firmware folder. Delete it.
#+begin_src sh
rm handwired_dactyl_manuform_5x6_default.hex
#+end_src

Don't bother to run ~qmk setup~. It would complain because our install is missing some toolchains for other microcontrollers, but we only need the avr-tools for the Atmega32U.

*** Install the keyboard into QMK
Put the [[file:dactyl_manuform_r_track/][dactyl_manuform_r_track]] folder into qmk_firmware/keyboards/handwired/

*** Customizing your key map
You can use the standard layouts, currently there is Colemak, Dvorak and Qwerty for the r_track.
For Dvorak and Qwerty the base layer is very similar to the standard US layout of the alphanumeric keys.
Here is the Dvorak base layer, the positions for the non-alphanumeric keys is the same for Qwerty base layer:
[[file:images/layer0.jpg]]

The Layer 1 and Layer 2 for Dvorak and Qwerty are the same. The MO(2) key will activate the second layer, when the MO(1) key from the base layer is pressed simultaneously.
[[file:images/layer1.jpg]] [[file:images/layer2.jpg]]

Inside your qmk_firmware folder there is a folder with the key maps for the r_track under ~keymaps/handwired/dactyl_manuform_r_track/keymaps~.
This folder contains sub folders with custom sets of key maps. Now you have two choices:
- Edit one of the existing key maps
- To make your own key map, copy a folder and rename it to your liking. Copy the folder with a key map that is closest to what you want to make. (If you want to make a Dvorak layout, it is easier to start with a anorak draft)

**** OPTION 1: the hardcore way with a text editor
***** Key layout
Either way you will find a ~keymap.c~ file inside of those folders. This file is compiled into the actual part of the firmware that determines the keymap. Inside there is a part that looks something like this:
#+begin_src c
const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
[_COLEMAKDHM] = LAYOUT_5x6(
DM_REC1,    DM_REC1, DM_PLY1, DM_REC2 , DM_PLY2 , DM_RSTP,               KC_CPI_DOWN, KC_CPI_STD , KC_CPI_UP , KC_SMO_SC , KC_0        ,KC_QUOT_MY,
KC_TAB,     KC_Q ,   KC_W   , KC_F    , KC_P    , KC_B   ,               KC_J    ,    KC_L       , KC_U      , KC_Y      , KC_SCLN_INV ,KC_QUOT_MY,
KC_ESC,     KC_A ,   KC_R   , KC_S    , KC_T    , KC_G   ,               KC_M    ,    KC_N       , KC_E      , KC_I      , KC_O        ,KC_MINS,
KC_TILD_MY, KC_Z ,   KC_X   , KC_C    , KC_D    , KC_V   ,               KC_K    ,    KC_H       , KC_COMM   , KC_DOT    , KC_SLSH     ,KC_BSLASH,
                           _______, _______,                                         _______, KC_LGUI,
                                       TD(SFT_TM),    TD(RAI_TM),          _______, KC_SPC,
                                       TD(CTL_TM),    TD(GUI_TM),          _______, KC_ENT,
                                       TD(ALT_TM),    TD(LOW_TM),          KC_BSPC, KC_DEL
),

[_LOWER] = LAYOUT_5x6(

KC_TILD, KC_EXLM     , KC_AT   , KC_HASH   , KC_DLR  ,KC_PERC,           KC_CIRC, KC_AMPR , KC_ASTR    , KC_LPRN  , KC_RPRN   ,           _______,
_______, KC_PGDN     , KC_HOME , KC_END    , KC_PGUP ,_______,           _______, _______ , RALT(KC_Y) , _______  , RALT(LSFT(KC_SCLN)) , _______,
_______, RALT(KC_Q)  , _______ ,RALT(KC_S) , KC_RBRC ,_______,           KC_BTN3, KC_BTN1 , RALT(KC_5) , KC_BTN2  , RALT(KC_P),           _______,
KC_F12 , KC_F1       , KC_F2   , KC_F3     , KC_F4   , KC_F5 ,           KC_F6  , KC_F7   , KC_F8      , KC_F9    , KC_F10    ,           KC_F11 ,
                            _______,_______,                             _______,_______,
                                        _______,_______,             _______,_______,
                                        _______,_______,             _______,_______,
                                        _______,_______,             _______,_______
),

[_RAISE] = LAYOUT_5x6(
_______, _______ , _______ , _______ , _______ ,_______,                 _______, _______      , _______      , _______     , _______     , _______,
_______,  KC_1   , KC_2    , KC_3    , KC_4    , KC_5  ,                 KC_6   , KC_7         , KC_8         , KC_9        , KC_0        , KC_QUOT,
_______, KC_LPRN , KC_RPRN , KC_LBRC , KC_RBRC ,KC_LBRC,                 KC_RBRC, LSFT(KC_LBRC),LSFT(KC_RBRC) ,LSFT(KC_COMM),LSFT(KC_DOT) ,KC_MS_BTN3,
KC_TILD, KC_EXLM , KC_AT   , KC_HASH , KC_DLR  ,KC_PERC,                 KC_CIRC, KC_AMPR      , KC_ASTR      , KC_PLUS     , KC_EQL      , KC_DEL,
                             _______,_______,                                _______,_______,
                                        _______,_______,             _______,_______,
                                        _______,_______,             _______,_______,
                                        _______,_______,             _______,_______
),
};
#+end_src

This represents the layout of the keys. In order to change a key, you have to exchange the keycode of that key with the one you want. Say you want to have escape on the first key in the second row. Then you would exchange ~KC_TAB~ there with ~KC_ESC~. If you do not know the keycode of a key, you could use [[https://config.qmk.fm/#/handwired/dactyl_manuform/5x6/LAYOUT_5x6][QMK Configurator]]. When you hover your mouse over a key in the keyboard image on the bottom of a page, it shows you the keys keycode in a bar a the bottom.
To get special key funtions like ~RALT(KC_Y)~ you can see them in the same way on the bottom in the "Quantum" tab.
Here is also a reference for the [[https://github.com/qmk/qmk_firmware/blob/master/docs/keycodes.md][keycodes used by QMK.]] There are a few.

The keys ~TD(SFT_TM), TD(CTL_M) ...~ are special functions of the firmware for this trackball dactyl. They modify the behavior of the trackball, when only hold. When they are hold and a key is pressed, they behave like the normal key would. E.g. TD(SFT_TM) together with 'g' behaves like the shift-key together with 'g' and prints a G.
Be aware that ~TD(RAI_TM)~ and ~TD(LOW_TM)~ are modifier keys to activate the _RAISE and _LOWER layer.
a
***** Layers
In the above example [_COLEMAKDHM], [_LOWER] and [_RAISE] are the names of the layers. You can put in any name for the COLEMAKDHM, but you have to change the ~#define~ lines at the beginning of the line accordingly.
#+begin_src c
#define _COLEMAKDHM 0
#+end_src
You better leave the RAISE and LOWER name like they are. You could change them, but you would have to change them everywhere in the file.
To add another layer, copy and past one of the existing layer, rename it to whatever you like, e.g. _MYLAYER. Then add a new ~#define _MYLAYER 3~ to the befinning of the file. Count the number up with every layer you add.
You bind your layer to a key with the keycode ~MO(_MYLAYER)~. MO switches a layer on like the shift, ctrl etc. keys. So when you hold that key, the layer is active. When you let go, the layer is not active. Again there are several other layer functions like ~TG()~ which toggles a layer. Look them up in QMK Configurator.


**** OPTION 2: Using QMK Configurator for similar keyboard
Because editing the keycodes is somewhat tedious, I came up with a way to utilize QMK Configurator a bit for it.
Go to [[https://config.qmk.fm/#/handwired/dactyl_manuform/5x6/LAYOUT_5x6][QMK Configurator]] and select the handwired/dactyl_manuform/5x6 keyboard. Rename the keyboard to whatever you like and edit your keyboard to your liking.
You can also put functions on the keys that do not really exist because of the trackball, the just wont work.
When you are done, export the key map as JSON and put it into the qmk_firmware folder. Then run the command
#+begin_src sh
./bin/qmk json-keymap handwired-dactyl_manuform-5x6-yourfilename.json >> mykeymap.c
#+end_src
With "yourfilename" changed to your actual filename of course. This will generate a C source file out of the JSON file. It will look something like this:
#+begin_src c
#include QMK_KEYBOARD_H

/* THIS FILE WAS GENERATED!
 *
 * This file was generated by qmk-compile-json. You may or may not want to
 * edit it directly.
 */

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
	[0] = LAYOUT_5x6(KC_GRV, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7, KC_8, KC_9, KC_0, KC_EQL, KC_TAB, KC_QUOT, KC_COMM, KC_DOT, KC_P, KC_Y, KC_F, KC_G, KC_C, KC_R, KC_L, KC_SLSH, KC_ESC, KC_A, KC_O, KC_E, KC_U, KC_I, KC_D, KC_H, KC_T, KC_N, KC_S, KC_MINS, KC_NO, KC_SCLN, KC_Q, KC_J, KC_K, KC_X, KC_B, KC_M, KC_W, KC_V, KC_Z, KC_BSLS, KC_LBRC, KC_RBRC, KC_PGUP, KC_PGDN, KC_LSFT, KC_NO, KC_NO, KC_RSFT, KC_LCTL, KC_SPC, KC_BSPC, KC_RALT, KC_LALT, MO(1), KC_ENT, LGUI_T(KC_RGUI)),
	[1] = LAYOUT_5x6(KC_TILD, KC_F1, KC_F2, KC_F3, KC_F4, KC_F5, KC_F6, KC_F7, KC_F8, KC_F9, KC_F10, KC_DEL, RCS(KC_2), KC_F9, KC_F10, LSFT(KC_F7), LCTL(KC_R), KC_LCBR, KC_RCBR, KC_HOME, KC_INS, KC_F11, KC_F12, KC_PLUS, KC_TRNS, RCS(KC_3), RCS(KC_4), MO(2), KC_DEL, KC_LPRN, KC_RPRN, KC_LEFT, KC_UP, KC_DOWN, KC_RGHT, KC_PIPE, KC_CAPS, LSFT(KC_F8), LSFT(KC_F9), LCTL(KC_X), LCTL(KC_C), LCTL(KC_V), KC_EQL, RCS(KC_3), RCS(KC_4), LSFT(KC_F8), LSFT(KC_F9), RCS(KC_2), LCTL(KC_F2), LCTL(KC_F3), KC_PSCR, KC_END, KC_LSFT, KC_TRNS, KC_TRNS, KC_RSFT, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS),
	[2] = LAYOUT_5x6(KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_NLCK, KC_PSLS, KC_PAST, KC_PMNS, KC_CALC, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_LBRC, KC_RBRC, KC_P7, KC_P8, KC_P9, KC_PPLS, KC_MUTE, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_LPRN, KC_RPRN, KC_P4, KC_P5, KC_P6, KC_TRNS, KC_VOLU, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_P0, KC_P1, KC_P2, KC_P3, KC_PEQL, KC_VOLD, KC_TRNS, KC_TRNS, KC_PDOT, KC_COMM, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS)
};
#+end_src

Where 0, 1 and 2 are the different layers.
While this is horrible to read of course, these layouts are perfectly valid key maps. But you have to make some changes first before you can use it in the r_tracks firmware.
First of all, copy only the part that says
#+begin_src c
	LAYOUT_5x6(KC_GRV, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7, KC_8, KC_9, KC_0, KC_EQL, KC_TAB, KC_QUOT, KC_COMM, KC_DOT, KC_P, KC_Y, KC_F, KC_G, KC_C, KC_R, KC_L, KC_SLSH, KC_ESC, KC_A, KC_O, KC_E, KC_U, KC_I, KC_D, KC_H, KC_T, KC_N, KC_S, KC_MINS, KC_NO, KC_SCLN, KC_Q, KC_J, KC_K, KC_X, KC_B, KC_M, KC_W, KC_V, KC_Z, KC_BSLS, KC_LBRC, KC_RBRC, KC_PGUP, KC_PGDN, KC_LSFT, KC_NO, KC_NO, KC_RSFT, KC_LCTL, KC_SPC, KC_BSPC, KC_RALT, KC_LALT, MO(1), KC_ENT, LGUI_T(KC_RGUI)),
#+end_src

into an existing r_track layouts ~keymap.c~. So you will not mess up the names of the layers. Then replace

| replace | with       |
|---------+------------|
| KC_LSFT | TD(SFT_TM) |
| KC_LGUI | TD(GUI_TM) |
| KC_LCTL | TD(CTL_TM) |
| KC_LALT | TD(ALT_TM) |
| MD(1)   | TD(LOW_TM) |
| MD(2)   | TD(RAI_TM) |
|---------+------------|


*** Compiling your firmware
Once you are done with setting up the keymap to your liking, you can generate a .hex file with the command
#+begin_src sh
qmk compile -kb handwired/dactyl_manuform_r_track -km <your-keymap>
#+end_src
while being inside the qmk_firmware folder. If you haven't screwed up your keymap.c from before, this will generate a .hex-file in the qmk_firmware folder.

** DRAFT: Flashing the compiled .hex file.
Flashing the firmware is the usual flashing of a QMK firmware. You either compiled it yourself on your computer, with somewhat finicky setup of the key map and compilation of the keymap.c, or with the rather comfortable [[https://config.qmk.fm/][QMK Configurator]]. Either way you are going to end up with a .hex file.
I have never flashed a QMK firmware onto an Arduino in Windows or Mac, but I guess it's rather easy using [[https://github.com/qmk/qmk_toolbox/releases][QMK Toolbox.]]

To flash a .hex in Linux you need to do the following:
*** Install avrdude
On Gentoo this is ~sudo emerge dev-embedded/avrdude~, on Ubuntu ~sudo apt install avrdude~ and I am confident someone nerdy enough to want to use such a keyboard knows how to install software on his/ her distro.
*** Get your device name
To get your device name in Linux you use the command ~dmesg | tail~. This shows you the end of the log of the kernel messages, so plug in the left side of the keyboard into your USB without the right side connected to it and run ~dmesg | tail~.
This will give you some output similar to
#+begin_src sh
~[26768.779976] cdc_acm 1-12:1.0: ttyACM0: USB ACM device~
#+end_src

Which is telling you that ~/dev/ttyACM0~ is the device name of your Arduino. Be aware that these device names are dynamic in Linux, so it could be ~/dev/ttyACM1~ next time, because you already have another Arduino (or some other USB/Serial device) plugged in, which already occupies ~/dev/ttyACM0~. Depending on your distro this could also be called ~/dev/ttyUSB~ instead.
If you can not find your device with ~dmesg | tail~, try finding it with
#+begin_src sh
find /dev -name '*ttyACM*' # or
find /dev -name '*ttyUSB*'.
#+end_src

It could be that the device is only accessible by root, so to get user access you can use ~sudo chmod 777 /dev/ttyACM0~, but this will only last until you reconnect the Arduino.
You could also find the group of the ttyACM* file with ~ls -la /dev | grep ttyACM~, which should output something like this:
~crw-rw-r-- 1 root dialout ... /dev/ttyACM~. Add yourself to the group dialout in this case to get read/write permissions with ~sudo adduser myUserName dialout~.
However, the group name dialout could depend on the distro. This change will be permanent.

*** Flashing the .hex
Now with all that information, use the command
#+begin_src sh
avrdude -v -patmega32u4 -cavr109 -P/dev/ttyACM0 -b57600 -Uflash:w:"handwired_dactyl_manuform_5x6_yourfilenamehere.hex":i
#+end_src
inside the folder where your .hex file is.
Where ~/dev/ttyACM0~ depends on the device name you obtained before and the filename of the .hex file is your own filename obviously.
Sometimes flashing Arduinos is a bit tricky. If they already have a program flashed to them, you put them into flashing mode by pressing the reset switch. Then they are in flashing mode for a few seconds before they start running in their normal mode again. So you have to press that reset switch then run that command fast. In case you did not add yourself to the group that owns /dev/ttyACM*, it could be that you have to find the name of that device (/dev/ttyACMsomething), change its permissions and run the command. All that in a few seconds. You could chain commands together with ~&&~, but I recommend adding yourself to that group instead.
